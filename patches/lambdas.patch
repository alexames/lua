diff --git a/lparser.c b/lparser.c
index b193b672..fd23821d 100644
--- a/lparser.c
+++ b/lparser.c
@@ -1036,6 +1036,33 @@ static void body (LexState *ls, expdesc *e, int ismethod, int line) {
 }
 
 
+static void simplebody (LexState *ls, expdesc *e, int line) {
+  /* simplebody -> parlist `|' expr END */
+  FuncState new_fs;
+  expdesc ebody;
+  BlockCnt bl;
+  new_fs.f = addprototype(ls);
+  new_fs.f->linedefined = line;
+  checknext(ls, '(');
+  open_func(ls, &new_fs, &bl);
+  parlist(ls);
+  checknext(ls, ')');
+  if (testnext(ls, TK_DO)) {
+    statlist(ls);
+    new_fs.f->lastlinedefined = ls->linenumber;
+    check_match(ls, TK_END, TK_DO, line);
+  } else {
+    int reg;
+    expr(ls, &ebody);
+    reg = luaK_exp2anyreg(&new_fs, &ebody);
+    luaK_ret(&new_fs, reg, 1);
+    new_fs.f->lastlinedefined = ls->linenumber;
+  }
+  codeclosure(ls, e);
+  close_func(ls);
+}
+
+
 static int explist (LexState *ls, expdesc *v) {
   /* explist -> expr { ',' expr } */
   int n = 1;  /* at least one expression */
@@ -1049,6 +1076,38 @@ static int explist (LexState *ls, expdesc *v) {
 }
 
 
+static void simpleretstat (LexState *ls) {
+  /* simpleretstat -> RETURN [explist] [';'] */
+  FuncState *fs = ls->fs;
+  expdesc e;
+  int nret;  /* number of values being returned */
+  int first = luaY_nvarstack(fs);  /* first slot to be returned */
+  if (block_follow(ls, 1) || ls->t.token == ';')
+    nret = 0;  /* return no values */
+  else {
+    nret = 1;
+    expr(ls, &e);
+    if (hasmultret(e.k)) {
+      luaK_setmultret(fs, &e);
+      if (e.k == VCALL && nret == 1 && !fs->bl->insidetbc) {  /* tail call? */
+        SET_OPCODE(getinstruction(fs,&e), OP_TAILCALL);
+        lua_assert(GETARG_A(getinstruction(fs,&e)) == luaY_nvarstack(fs));
+      }
+      nret = LUA_MULTRET;  /* return all values */
+    }
+    else {
+      if (nret == 1)  /* only one single value? */
+        first = luaK_exp2anyreg(fs, &e);  /* can use original slot */
+      else {  /* values must go to the top of the stack */
+        luaK_exp2nextreg(fs, &e);
+        lua_assert(nret == fs->freereg - first);
+      }
+    }
+  }
+  luaK_ret(fs, first, nret);
+}
+
+
 static void funcargs (LexState *ls, expdesc *f) {
   FuncState *fs = ls->fs;
   expdesc args;
@@ -1076,6 +1135,11 @@ static void funcargs (LexState *ls, expdesc *f) {
       luaX_next(ls);  /* must use 'seminfo' before 'next' */
       break;
     }
+    case '$': {
+      luaX_next(ls);
+      simplebody(ls, &args, ls->linenumber);
+      break;
+    }
     default: {
       luaX_syntaxerror(ls, "function arguments expected");
     }
@@ -1154,7 +1218,7 @@ static void suffixedexp (LexState *ls, expdesc *v) {
         funcargs(ls, v);
         break;
       }
-      case '(': case TK_STRING: case '{': {  /* funcargs */
+      case '(': case TK_STRING: case '{': case '$': {  /* funcargs */
         luaK_exp2nextreg(fs, v);
         funcargs(ls, v);
         break;
@@ -1211,6 +1275,11 @@ static void simpleexp (LexState *ls, expdesc *v) {
       body(ls, v, 0, ls->linenumber);
       return;
     }
+    case '$': {  /* lambda */
+      luaX_next(ls);
+      simplebody(ls, v, ls->linenumber);
+      return;
+    }
     default: {
       suffixedexp(ls, v);
       return;
