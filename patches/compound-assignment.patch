diff --git a/llex.c b/llex.c
index b2e77c9c..4c409188 100644
--- a/llex.c
+++ b/llex.c
@@ -49,7 +49,8 @@ static const char *const luaX_tokens [] = {
     "return", "then", "true", "until", "while",
     "//", "..", "...", "==", ">=", "<=", "~=",
     "<<", ">>", "::", "<eof>",
-    "<number>", "<integer>", "<name>", "<string>"
+    "<number>", "<integer>", "<name>", "<string>",
+    "+=", "-=", "*=", "/=", "<<=", ">>=", "&=", "|=", "^="
 };
 
 
@@ -461,6 +462,7 @@ static int llex (LexState *ls, SemInfo *seminfo) {
       }
       case '-': {  /* '-' or '--' (comment) */
         next(ls);
+        if (check_next1(ls, '=')) return TK_MINUSEQ;
         if (ls->current != '-') return '-';
         /* else is a comment */
         next(ls);
@@ -496,20 +498,52 @@ static int llex (LexState *ls, SemInfo *seminfo) {
       case '<': {
         next(ls);
         if (check_next1(ls, '=')) return TK_LE;  /* '<=' */
-        else if (check_next1(ls, '<')) return TK_SHL;  /* '<<' */
+        else if (check_next1(ls, '<')) {
+          if ( check_next1(ls, '=') ) return TK_SHLEQ;  /* '<<=' */
+          else return TK_SHL;  /* '<<' */
+        }
         else return '<';
       }
       case '>': {
         next(ls);
         if (check_next1(ls, '=')) return TK_GE;  /* '>=' */
-        else if (check_next1(ls, '>')) return TK_SHR;  /* '>>' */
+        else if (check_next1(ls, '>')) {
+          if ( check_next1(ls, '=') ) return TK_SHREQ;  /* '>>=' */
+          else return TK_SHR;  /* '>>' */
+        }
         else return '>';
       }
       case '/': {
         next(ls);
         if (check_next1(ls, '/')) return TK_IDIV;  /* '//' */
+        if (check_next1(ls, '=')) return TK_DIVEQ;  /* '/=' */
         else return '/';
       }
+      case '+': {
+        next(ls);
+        if (check_next1(ls, '=')) return TK_PLUSEQ;  /* '+=' */
+        else return '+';
+      }
+      case '*': {
+        next(ls);
+        if (check_next1(ls, '=')) return TK_MULTEQ;  /* '*=' */
+        else return '*';
+      }
+      case '&': {
+        next(ls);
+        if (check_next1(ls, '=')) return TK_BANDEQ;  /* '&=' */
+        else return '&';
+      }
+      case '|': {
+        next(ls);
+        if (check_next1(ls, '=')) return TK_BOREQ;  /* '|=' */
+        else return '|';
+      }
+      case '^': {
+        next(ls);
+        if (check_next1(ls, '=')) return TK_BXOREQ;  /* '^=' */
+        else return '^';
+      }
       case '~': {
         next(ls);
         if (check_next1(ls, '=')) return TK_NE;  /* '~=' */
diff --git a/llex.h b/llex.h
index 389d2f86..df307d61 100644
--- a/llex.h
+++ b/llex.h
@@ -39,7 +39,8 @@ enum RESERVED {
   TK_IDIV, TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE,
   TK_SHL, TK_SHR,
   TK_DBCOLON, TK_EOS,
-  TK_FLT, TK_INT, TK_NAME, TK_STRING
+  TK_FLT, TK_INT, TK_NAME, TK_STRING,
+  TK_PLUSEQ, TK_MINUSEQ, TK_MULTEQ, TK_DIVEQ, TK_SHLEQ, TK_SHREQ, TK_BANDEQ, TK_BOREQ, TK_BXOREQ
 };
 
 /* number of reserved words */
diff --git a/lparser.c b/lparser.c
index d4d4237c..d6c54b76 100644
--- a/lparser.c
+++ b/lparser.c
@@ -1254,6 +1254,15 @@ static BinOpr getbinopr (int op) {
     case TK_GE: return OPR_GE;
     case TK_AND: return OPR_AND;
     case TK_OR: return OPR_OR;
+    case TK_PLUSEQ: return OPR_ADD;
+    case TK_MINUSEQ: return OPR_SUB;
+    case TK_MULTEQ: return OPR_MUL;
+    case TK_DIVEQ: return OPR_DIV;
+    case TK_SHLEQ: return OPR_SHL;
+    case TK_SHREQ: return OPR_SHR;
+    case TK_BANDEQ: return OPR_BAND;
+    case TK_BOREQ: return OPR_BOR;
+    case TK_BXOREQ: return OPR_BXOR;
     default: return OPR_NOBINOPR;
   }
 }
@@ -1393,12 +1402,50 @@ static void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v) {
   }
 }
 
+static void compound_assignment(LexState *ls, expdesc* v) {
+  BinOpr op = getbinopr(ls->t.token);
+  FuncState *fs = ls->fs;
+  int tolevel = fs->nactvar;
+  int old_free = fs->freereg;
+  expdesc e, infix;
+  int line = ls->linenumber;
+  int nextra, i;
+  luaX_next(ls);
+  /* create temporary local variables to lock up any registers needed
+     by indexed lvalues. */
+  lu_byte top = fs->nactvar;
+  /* protect both the table and index result registers,
+     ensuring that they won't be overwritten prior to the
+     storevar calls. */
+  if (vkisindexed(v->k)) {
+    if (v->u.ind.t >= top)
+      top = v->u.ind.t + 1;
+    if (v->k == VINDEXED && v->u.ind.idx >= top)
+      top = v->u.ind.idx + 1;
+  }
+  nextra = top - fs->nactvar;
+  if (nextra) {
+    for (i=0; i < nextra; i++) {
+      new_localvarliteral(ls, "(temp)");
+    }
+    adjustlocalvars(ls,nextra);
+  }
+  infix = *v;
+  luaK_infix(fs, op, &infix);
+  expr(ls, &e);
+  luaK_posfix(fs, op, &infix, &e, line);
+  luaK_storevar(fs, v, &infix);
+  removevars(fs, tolevel);
+  if (old_free < fs->freereg)
+    fs->freereg = old_free;
+}
+
 /*
 ** Parse and compile a multiple assignment. The first "variable"
 ** (a 'suffixedexp') was already read by the caller.
 **
 ** assignment -> suffixedexp restassign
-** restassign -> ',' suffixedexp restassign | '=' explist
+** restassign -> ',' suffixedexp restassign | '=' explist | opeq expr
 */
 static void restassign (LexState *ls, struct LHS_assign *lh, int nvars) {
   expdesc e;
@@ -1414,10 +1461,8 @@ static void restassign (LexState *ls, struct LHS_assign *lh, int nvars) {
     restassign(ls, &nv, nvars+1);
     leavelevel(ls);
   }
-  else {  /* restassign -> '=' explist */
-    int nexps;
-    checknext(ls, '=');
-    nexps = explist(ls, &e);
+  else if (testnext(ls, '=')) {  /* restassign -> '=' explist */
+    int nexps = explist(ls, &e);
     if (nexps != nvars)
       adjust_assign(ls, nvars, nexps, &e);
     else {
@@ -1426,7 +1471,12 @@ static void restassign (LexState *ls, struct LHS_assign *lh, int nvars) {
       return;  /* avoid default */
     }
   }
-  init_exp(&e, VNONRELOC, ls->fs->freereg-1);  /* default assignment */
+  else if ( ls->t.token >= TK_PLUSEQ && ls->t.token <= TK_BXOREQ ) { /* restassign -> opeq expr */
+    check_condition(ls, nvars == 1, "compound assignment not allowed on tuples");
+    compound_assignment(ls, &lh->v);
+    return;
+  }
+  init_exp(&e, VNONRELOC, ls->fs->freereg - 1);  /* default assignment */
   luaK_storevar(ls->fs, &lh->v, &e);
 }
 
@@ -1826,7 +1876,8 @@ static void exprstat (LexState *ls) {
   struct LHS_assign v;
   suffixedexp(ls, &v.v);
   /* stat -> assignment ? */
-  if (ls->t.token == '=' || ls->t.token == ',') {
+  if (ls->t.token == '=' || ls->t.token == ',' ||
+      (ls->t.token >= TK_PLUSEQ && ls->t.token <= TK_BXOREQ) ) {
     v.prev = NULL;
     restassign(ls, &v, 1);
   }
